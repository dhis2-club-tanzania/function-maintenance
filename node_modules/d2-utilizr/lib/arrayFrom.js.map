{"version":3,"sources":["../src/arrayFrom.js"],"names":["arrayFrom","param","isNewRef","toArray","iterable","start","end","length","split","supportsSliceOnNodeList","slice","call","array","i","push","undefined","Array","prototype","type","apply"],"mappings":";;;;;;;;kBAWwBA,S;;AAXxB;;;;;;AAEA;;;;;;;;;AASe,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoC;AAC/C,QAAIC,UAAU,SAAVA,OAAU,CAASC,QAAT,EAAmBC,KAAnB,EAA0BC,GAA1B,EAA+B;AACzC,YAAI,CAACF,QAAD,IAAa,CAACA,SAASG,MAA3B,EAAmC;AAC/B,mBAAO,EAAP;AACH;;AAED;AACA,YAAI,OAAOH,QAAP,KAAoB,QAAxB,EAAkC;AAC9BA,uBAAWA,SAASI,KAAT,CAAe,EAAf,CAAX;AACH;;AAED,YAAIC,uBAAJ,EAA6B;AAAE;AAC3B,mBAAOC,MAAMC,IAAN,CAAWP,QAAX,EAAqBC,SAAS,CAA9B,EAAiCC,OAAOF,SAASG,MAAjD,CAAP;AACH;;AAED,YAAIK,QAAQ,EAAZ;AAAA,YACIC,CADJ;;AAGA;AACAR,gBAAQA,SAAS,CAAjB;AACAC,cAAMA,MAAQA,MAAM,CAAP,GAAYF,SAASG,MAAT,GAAkBD,GAA9B,GAAoCA,GAA3C,GAAkDF,SAASG,MAAjE;;AAEA,aAAKM,IAAIR,KAAT,EAAgBQ,IAAIP,GAApB,EAAyBO,GAAzB,EAA8B;AAC1BD,kBAAME,IAAN,CAAWV,SAASS,CAAT,CAAX;AACH;;AAED,eAAOD,KAAP;AACH,KA1BD;;AA4BA,QAAIX,UAAUc,SAAV,IAAuBd,UAAU,IAArC,EAA2C;AACvC,eAAO,EAAP;AACH;;AAED,QAAI,uBAAQA,KAAR,CAAJ,EAAoB;AAChB,eAAQC,QAAD,GAAac,MAAMC,SAAN,CAAgBP,KAAhB,CAAsBC,IAAtB,CAA2BV,KAA3B,CAAb,GAAiDA,KAAxD;AACH;;AAED,QAAIiB,cAAcjB,KAAd,yCAAcA,KAAd,CAAJ;AACA,QAAIA,SAASA,MAAMM,MAAN,KAAiBQ,SAA1B,IAAuCG,SAAS,QAAhD,KAA6DA,SAAS,UAAT,IAAuB,CAACjB,MAAMkB,KAA3F,CAAJ,EAAuG;AACnG;AACA,eAAOhB,QAAQF,KAAR,CAAP;AACH;;AAED,WAAO,CAACA,KAAD,CAAP;AACH","file":"arrayFrom.js","sourcesContent":["import isArray from './isArray';\n\n/**\n * Create an array from a value\n *\n * @param {*} param Value to transform to an array\n * @param {boolean} [isNewRef] Should return a new reference than the one from the `param` value\n * @returns {Array} The resulting array\n *\n * @requires isArray\n */\nexport default function arrayFrom(param, isNewRef) {\n    var toArray = function(iterable, start, end) {\n        if (!iterable || !iterable.length) {\n            return [];\n        }\n\n        // FIXME: This will never be called as the if check excludes type string\n        if (typeof iterable === 'string') {\n            iterable = iterable.split('');\n        }\n\n        if (supportsSliceOnNodeList) { // FIXME: This does not exist\n            return slice.call(iterable, start || 0, end || iterable.length);\n        }\n\n        var array = [],\n            i;\n\n        // FIXME: start and end are always 0 and iterable.length\n        start = start || 0;\n        end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;\n\n        for (i = start; i < end; i++) {\n            array.push(iterable[i]);\n        }\n\n        return array;\n    };\n\n    if (param === undefined || param === null) {\n        return [];\n    }\n\n    if (isArray(param)) {\n        return (isNewRef) ? Array.prototype.slice.call(param) : param;\n    }\n\n    var type = typeof param;\n    if (param && param.length !== undefined && type !== 'string' && (type !== 'function' || !param.apply)) {\n        // TODO: This function call will always fail because of supportsSliceOnNodeList being undefined\n        return toArray(param);\n    }\n\n    return [param];\n}\n"]}