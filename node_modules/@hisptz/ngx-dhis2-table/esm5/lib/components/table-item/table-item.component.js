/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { drawTable } from '../../helpers/index';
var TableItemComponent = /** @class */ (function () {
    function TableItemComponent() {
        this.sort_direction = [];
        this.current_sorting = [];
        this.tableObject = null;
    }
    /**
     * @return {?}
     */
    TableItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.analyticsObject && this.tableConfiguration) {
            this.tableObject = drawTable(this.analyticsObject, this.tableConfiguration);
        }
    };
    /**
     * @param {?} tableObject
     * @param {?} n
     * @param {?} isLastItem
     * @return {?}
     */
    TableItemComponent.prototype.sortData = /**
     * @param {?} tableObject
     * @param {?} n
     * @param {?} isLastItem
     * @return {?}
     */
    function (tableObject, n, isLastItem) {
        if (tableObject.columns.length === 1 && isLastItem) {
            this.current_sorting = [];
            this.current_sorting[n] = true;
            var /** @type {?} */ table = void 0, /** @type {?} */
            rows = void 0, /** @type {?} */
            switching = void 0, /** @type {?} */
            i = void 0, /** @type {?} */
            x = void 0, /** @type {?} */
            y = void 0, /** @type {?} */
            shouldSwitch = void 0, /** @type {?} */
            dir = void 0, /** @type {?} */
            switchcount = 0;
            table = document.getElementById('myPivotTable');
            switching = true;
            //  Set the sorting direction to ascending:
            dir = 'asc';
            /*Make a loop that will continue until
                   no switching has been done:*/
            while (switching) {
                //  start by saying: no switching is done:
                switching = false;
                rows = table.getElementsByTagName('TR');
                /*Loop through all table rows (except the
                         first, which contains table headers):*/
                for (i = 0; i < rows.length - 1; i++) {
                    // start by saying there should be no switching:
                    shouldSwitch = false;
                    /*Get the two elements you want to compare,
                               one from current row and one from the next:*/
                    x = rows[i].getElementsByTagName('TD')[n];
                    y = rows[i + 1].getElementsByTagName('TD')[n];
                    /*check if the two rows should switch place,
                               based on the direction, asc or desc:*/
                    if (dir === 'asc') {
                        if (parseFloat(x.innerHTML)) {
                            if (parseFloat(x.innerHTML) > parseFloat(y.innerHTML)) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        else {
                            if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        this.sort_direction[n] = 'asc';
                    }
                    else if (dir === 'desc') {
                        if (parseFloat(x.innerHTML)) {
                            if (parseFloat(x.innerHTML) < parseFloat(y.innerHTML)) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        else {
                            if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        this.sort_direction[n] = 'desc';
                    }
                }
                if (shouldSwitch) {
                    /*If a switch has been marked, make the switch
                               and mark that a switch has been done:*/
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    // Each time a switch is done, increase this count by 1:
                    switchcount++;
                }
                else {
                    /*If no switching has been done AND the direction is 'asc',
                               set the direction to 'desc' and run the while loop again.*/
                    if (switchcount === 0 && dir === 'asc') {
                        dir = 'desc';
                        this.sort_direction[n] = 'desc';
                        switching = true;
                    }
                }
            }
        }
    };
    TableItemComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'ngx-dhis2-table-item',
                    template: "<div class=\"row\">\n    <div class=\"col-md-12\" *ngIf=\"tableObject\">\n        <h5 style=\"margin-top: 80px\" class=\"text-center\" *ngIf=\"tableObject.rows.length == 0\"> No data to display</h5>\n\n        <div *ngIf=\"tableObject\" style=\"padding: 3px\">\n            <!--<h4 *ngIf=\"tableObject.rows.length != 0\" class=\"text-center\" style=\"margin-bottom: 0px\">{{tableObject?.title}}</h4>-->\n            <table class=\"table table-bordered table-responsive table-condensed custom-table\" *ngIf=\"tableObject.rows.length != 0\">\n                <thead>\n                    <!--title-->\n                    <tr class=\"table-title\">\n                        <th [attr.colspan]=\"tableObject.rows[0].items.length\">\n                            <h4 style=\"margin: 0px\" class=\"text-center\">{{tableObject.subtitle}} </h4>\n                        </th>\n                    </tr>\n                    <!--headers-->\n                    <tr *ngFor=\"let header of tableObject.headers; let j = index\" class=\"header-column\">\n                        <th *ngIf=\"tableObject.hasParentOu\"></th>\n                        <th *ngFor=\"let table_column of tableObject.columns; let i = index\" style=\"text-align: center\">\n                            <span *ngIf=\"i==tableObject.columns.length-1 && j==tableObject.headers.length-1 && tableObject.titlesAvailable\">{{ tableObject.titles.rows[i] }} / {{ tableObject.titles.column[j]}}</span>\n                            <span *ngIf=\"i != tableObject.columns.length-1\">{{ tableObject.titles.rows[i] }}</span>\n                            <span *ngIf=\"j != tableObject.headers.length-1\">{{ tableObject.titles.column[j] }}</span>\n                        </th>\n                        <th *ngFor=\"let header_column of header.items; let i=index\" [colSpan]=\"header_column.span\" style=\"text-align: center\" (click)=\"sortData(tableObject,i+tableObject.columns.length,j+1==tableObject.headers.length)\">\n                            {{ header_column.name }}\n                            <span *ngIf=\"j+1==tableObject.headers.length && current_sorting[i+tableObject.columns.length] && sort_direction[i+tableObject.columns.length] == 'asc'\" class=\"glyphicon glyphicon-triangle-top pull-right\"></span>\n                            <span *ngIf=\"j+1==tableObject.headers.length && current_sorting[i+tableObject.columns.length] && sort_direction[i+tableObject.columns.length] == 'desc'\" class=\"glyphicon glyphicon-triangle-bottom pull-right\"></span>\n                        </th>\n                    </tr>\n                </thead>\n                <tbody id=\"myPivotTable\">\n                    <tr *ngFor=\"let row of tableObject.rows\" [ngClass]=\"{'sub-total': row.sub_total}\">\n                        <td *ngFor=\"let header_column of row.items;let i = index\" [ngClass]=\"{'header-column': header_column.name != ''}\" style=\"text-align: center;vertical-align: middle\" [attr.rowspan]=\"header_column.row_span\" [style.background]=\"header_column.color\">\n                            {{ header_column.val }}\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n\n\n        </div>\n    </div>\n</div>",
                    styles: [".table-item-container{overflow:hidden}.custom-table{display:table;border-style:none!important;width:100%}.custom-table td,.custom-table th{border:thin solid #f1f1f1}.custom-table>tbody>tr>td,.custom-table>thead>tr>th{font-size:13px!important}table tr th{background-color:rgba(238,238,238,.29);padding:4px;text-align:center}table tr td{padding:4px}table tr td:first-child{background-color:rgba(238,238,238,.29)}.table-title{font-size:13px;font-weight:600;text-align:center}"]
                },] },
    ];
    /** @nocollapse */
    TableItemComponent.ctorParameters = function () { return []; };
    TableItemComponent.propDecorators = {
        tableConfiguration: [{ type: Input }],
        analyticsObject: [{ type: Input }]
    };
    return TableItemComponent;
}());
export { TableItemComponent };
function TableItemComponent_tsickle_Closure_declarations() {
    /** @type {?} */
    TableItemComponent.prototype.tableConfiguration;
    /** @type {?} */
    TableItemComponent.prototype.analyticsObject;
    /** @type {?} */
    TableItemComponent.prototype.tableObject;
    /** @type {?} */
    TableItemComponent.prototype.sort_direction;
    /** @type {?} */
    TableItemComponent.prototype.current_sorting;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaXRlbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGlzcHR6L25neC1kaGlzMi10YWJsZS8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3RhYmxlLWl0ZW0vdGFibGUtaXRlbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBR3pELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7SUF1RDlDOzhCQUYyQixFQUFFOytCQUNBLEVBQUU7UUFFN0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7S0FDekI7Ozs7SUFFRCxxQ0FBUTs7O0lBQVI7UUFDRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQzFCLElBQUksQ0FBQyxlQUFlLEVBQ3BCLElBQUksQ0FBQyxrQkFBa0IsQ0FDeEIsQ0FBQztTQUNIO0tBQ0Y7Ozs7Ozs7SUFFRCxxQ0FBUTs7Ozs7O0lBQVIsVUFBUyxXQUFXLEVBQUUsQ0FBQyxFQUFFLFVBQVU7UUFDakMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDbkQsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7WUFDMUIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDL0IscUJBQUksS0FBSyxTQUFBO1lBQ1AsSUFBSSxTQUFBO1lBQ0osU0FBUyxTQUFBO1lBQ1QsQ0FBQyxTQUFBO1lBQ0QsQ0FBQyxTQUFBO1lBQ0QsQ0FBQyxTQUFBO1lBQ0QsWUFBWSxTQUFBO1lBQ1osR0FBRyxTQUFBO1lBQ0gsV0FBVyxH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ZjtnQkFBQyxJQUFJLENBQUMsQ0FBQzs7O29CQUdOLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7d0JBQ3ZDLEdBQUcsR0FBRyxNQUFNLENBQUM7d0JBQ2IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7d0JBQ2hDLFNBQVMsR0FBRyxJQUFJLENBQUM7cUJBQ2xCO2lCQUNGO2FBQ0Y7U0FDRjtLQUNGOztnQkF0SkYsU0FBUyxTQUFDOztvQkFFVCxRQUFRLEVBQUUsc0JBQXNCO29CQUNoQyxRQUFRLEVBQUUsb3FHQXlDTDtvQkFDTCxNQUFNLEVBQUUsQ0FBQywwZEFBMGQsQ0FBQztpQkFDcmU7Ozs7O3FDQUVFLEtBQUs7a0NBQ0wsS0FBSzs7NkJBdERSOztTQW9EYSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYmxlQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy90YWJsZS1jb25maWd1cmF0aW9uJztcblxuaW1wb3J0IHsgZHJhd1RhYmxlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnbmd4LWRoaXMyLXRhYmxlLWl0ZW0nLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgKm5nSWY9XCJ0YWJsZU9iamVjdFwiPlxuICAgICAgICA8aDUgc3R5bGU9XCJtYXJnaW4tdG9wOiA4MHB4XCIgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiICpuZ0lmPVwidGFibGVPYmplY3Qucm93cy5sZW5ndGggPT0gMFwiPiBObyBkYXRhIHRvIGRpc3BsYXk8L2g1PlxuXG4gICAgICAgIDxkaXYgKm5nSWY9XCJ0YWJsZU9iamVjdFwiIHN0eWxlPVwicGFkZGluZzogM3B4XCI+XG4gICAgICAgICAgICA8IS0tPGg0ICpuZ0lmPVwidGFibGVPYmplY3Qucm93cy5sZW5ndGggIT0gMFwiIGNsYXNzPVwidGV4dC1jZW50ZXJcIiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDBweFwiPnt7dGFibGVPYmplY3Q/LnRpdGxlfX08L2g0Pi0tPlxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtYm9yZGVyZWQgdGFibGUtcmVzcG9uc2l2ZSB0YWJsZS1jb25kZW5zZWQgY3VzdG9tLXRhYmxlXCIgKm5nSWY9XCJ0YWJsZU9iamVjdC5yb3dzLmxlbmd0aCAhPSAwXCI+XG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8IS0tdGl0bGUtLT5cbiAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwidGFibGUtdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBbYXR0ci5jb2xzcGFuXT1cInRhYmxlT2JqZWN0LnJvd3NbMF0uaXRlbXMubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0IHN0eWxlPVwibWFyZ2luOiAwcHhcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+e3t0YWJsZU9iamVjdC5zdWJ0aXRsZX19IDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8IS0taGVhZGVycy0tPlxuICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVwibGV0IGhlYWRlciBvZiB0YWJsZU9iamVjdC5oZWFkZXJzOyBsZXQgaiA9IGluZGV4XCIgY2xhc3M9XCJoZWFkZXItY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggKm5nSWY9XCJ0YWJsZU9iamVjdC5oYXNQYXJlbnRPdVwiPjwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggKm5nRm9yPVwibGV0IHRhYmxlX2NvbHVtbiBvZiB0YWJsZU9iamVjdC5jb2x1bW5zOyBsZXQgaSA9IGluZGV4XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImk9PXRhYmxlT2JqZWN0LmNvbHVtbnMubGVuZ3RoLTEgJiYgaj09dGFibGVPYmplY3QuaGVhZGVycy5sZW5ndGgtMSAmJiB0YWJsZU9iamVjdC50aXRsZXNBdmFpbGFibGVcIj57eyB0YWJsZU9iamVjdC50aXRsZXMucm93c1tpXSB9fSAvIHt7IHRhYmxlT2JqZWN0LnRpdGxlcy5jb2x1bW5bal19fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImkgIT0gdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGgtMVwiPnt7IHRhYmxlT2JqZWN0LnRpdGxlcy5yb3dzW2ldIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaiAhPSB0YWJsZU9iamVjdC5oZWFkZXJzLmxlbmd0aC0xXCI+e3sgdGFibGVPYmplY3QudGl0bGVzLmNvbHVtbltqXSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggKm5nRm9yPVwibGV0IGhlYWRlcl9jb2x1bW4gb2YgaGVhZGVyLml0ZW1zOyBsZXQgaT1pbmRleFwiIFtjb2xTcGFuXT1cImhlYWRlcl9jb2x1bW4uc3BhblwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCIgKGNsaWNrKT1cInNvcnREYXRhKHRhYmxlT2JqZWN0LGkrdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGgsaisxPT10YWJsZU9iamVjdC5oZWFkZXJzLmxlbmd0aClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBoZWFkZXJfY29sdW1uLm5hbWUgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImorMT09dGFibGVPYmplY3QuaGVhZGVycy5sZW5ndGggJiYgY3VycmVudF9zb3J0aW5nW2krdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGhdICYmIHNvcnRfZGlyZWN0aW9uW2krdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGhdID09ICdhc2MnXCIgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLXRvcCBwdWxsLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaisxPT10YWJsZU9iamVjdC5oZWFkZXJzLmxlbmd0aCAmJiBjdXJyZW50X3NvcnRpbmdbaSt0YWJsZU9iamVjdC5jb2x1bW5zLmxlbmd0aF0gJiYgc29ydF9kaXJlY3Rpb25baSt0YWJsZU9iamVjdC5jb2x1bW5zLmxlbmd0aF0gPT0gJ2Rlc2MnXCIgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLWJvdHRvbSBwdWxsLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keSBpZD1cIm15UGl2b3RUYWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVwibGV0IHJvdyBvZiB0YWJsZU9iamVjdC5yb3dzXCIgW25nQ2xhc3NdPVwieydzdWItdG90YWwnOiByb3cuc3ViX3RvdGFsfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBoZWFkZXJfY29sdW1uIG9mIHJvdy5pdGVtcztsZXQgaSA9IGluZGV4XCIgW25nQ2xhc3NdPVwieydoZWFkZXItY29sdW1uJzogaGVhZGVyX2NvbHVtbi5uYW1lICE9ICcnfVwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyO3ZlcnRpY2FsLWFsaWduOiBtaWRkbGVcIiBbYXR0ci5yb3dzcGFuXT1cImhlYWRlcl9jb2x1bW4ucm93X3NwYW5cIiBbc3R5bGUuYmFja2dyb3VuZF09XCJoZWFkZXJfY29sdW1uLmNvbG9yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgaGVhZGVyX2NvbHVtbi52YWwgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG5cblxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PmAsXG4gIHN0eWxlczogW2AudGFibGUtaXRlbS1jb250YWluZXJ7b3ZlcmZsb3c6aGlkZGVufS5jdXN0b20tdGFibGV7ZGlzcGxheTp0YWJsZTtib3JkZXItc3R5bGU6bm9uZSFpbXBvcnRhbnQ7d2lkdGg6MTAwJX0uY3VzdG9tLXRhYmxlIHRkLC5jdXN0b20tdGFibGUgdGh7Ym9yZGVyOnRoaW4gc29saWQgI2YxZjFmMX0uY3VzdG9tLXRhYmxlPnRib2R5PnRyPnRkLC5jdXN0b20tdGFibGU+dGhlYWQ+dHI+dGh7Zm9udC1zaXplOjEzcHghaW1wb3J0YW50fXRhYmxlIHRyIHRoe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzgsMjM4LDIzOCwuMjkpO3BhZGRpbmc6NHB4O3RleHQtYWxpZ246Y2VudGVyfXRhYmxlIHRyIHRke3BhZGRpbmc6NHB4fXRhYmxlIHRyIHRkOmZpcnN0LWNoaWxke2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzgsMjM4LDIzOCwuMjkpfS50YWJsZS10aXRsZXtmb250LXNpemU6MTNweDtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXJ9YF1cbn0pXG5leHBvcnQgY2xhc3MgVGFibGVJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCkgdGFibGVDb25maWd1cmF0aW9uOiBUYWJsZUNvbmZpZ3VyYXRpb247XG4gIEBJbnB1dCgpIGFuYWx5dGljc09iamVjdDogYW55O1xuICB0YWJsZU9iamVjdDogYW55O1xuICBzb3J0X2RpcmVjdGlvbjogc3RyaW5nW10gPSBbXTtcbiAgY3VycmVudF9zb3J0aW5nOiBib29sZWFuW10gPSBbXTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50YWJsZU9iamVjdCA9IG51bGw7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5hbmFseXRpY3NPYmplY3QgJiYgdGhpcy50YWJsZUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMudGFibGVPYmplY3QgPSBkcmF3VGFibGUoXG4gICAgICAgIHRoaXMuYW5hbHl0aWNzT2JqZWN0LFxuICAgICAgICB0aGlzLnRhYmxlQ29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzb3J0RGF0YSh0YWJsZU9iamVjdCwgbiwgaXNMYXN0SXRlbSkge1xuICAgIGlmICh0YWJsZU9iamVjdC5jb2x1bW5zLmxlbmd0aCA9PT0gMSAmJiBpc0xhc3RJdGVtKSB7XG4gICAgICB0aGlzLmN1cnJlbnRfc29ydGluZyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50X3NvcnRpbmdbbl0gPSB0cnVlO1xuICAgICAgbGV0IHRhYmxlLFxuICAgICAgICByb3dzLFxuICAgICAgICBzd2l0Y2hpbmcsXG4gICAgICAgIGksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHNob3VsZFN3aXRjaCxcbiAgICAgICAgZGlyLFxuICAgICAgICBzd2l0Y2hjb3VudCA9IDA7XG4gICAgICB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVBpdm90VGFibGUnKTtcbiAgICAgIHN3aXRjaGluZyA9IHRydWU7XG4gICAgICAvLyAgU2V0IHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB0byBhc2NlbmRpbmc6XG4gICAgICBkaXIgPSAnYXNjJztcbiAgICAgIC8qTWFrZSBhIGxvb3AgdGhhdCB3aWxsIGNvbnRpbnVlIHVudGlsXG4gICAgICAgbm8gc3dpdGNoaW5nIGhhcyBiZWVuIGRvbmU6Ki9cbiAgICAgIHdoaWxlIChzd2l0Y2hpbmcpIHtcbiAgICAgICAgLy8gIHN0YXJ0IGJ5IHNheWluZzogbm8gc3dpdGNoaW5nIGlzIGRvbmU6XG4gICAgICAgIHN3aXRjaGluZyA9IGZhbHNlO1xuICAgICAgICByb3dzID0gdGFibGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1RSJyk7XG4gICAgICAgIC8qTG9vcCB0aHJvdWdoIGFsbCB0YWJsZSByb3dzIChleGNlcHQgdGhlXG4gICAgICAgICBmaXJzdCwgd2hpY2ggY29udGFpbnMgdGFibGUgaGVhZGVycyk6Ki9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgLy8gc3RhcnQgYnkgc2F5aW5nIHRoZXJlIHNob3VsZCBiZSBubyBzd2l0Y2hpbmc6XG4gICAgICAgICAgc2hvdWxkU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgLypHZXQgdGhlIHR3byBlbGVtZW50cyB5b3Ugd2FudCB0byBjb21wYXJlLFxuICAgICAgICAgICBvbmUgZnJvbSBjdXJyZW50IHJvdyBhbmQgb25lIGZyb20gdGhlIG5leHQ6Ki9cbiAgICAgICAgICB4ID0gcm93c1tpXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVEQnKVtuXTtcbiAgICAgICAgICB5ID0gcm93c1tpICsgMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1REJylbbl07XG4gICAgICAgICAgLypjaGVjayBpZiB0aGUgdHdvIHJvd3Mgc2hvdWxkIHN3aXRjaCBwbGFjZSxcbiAgICAgICAgICAgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiwgYXNjIG9yIGRlc2M6Ki9cbiAgICAgICAgICBpZiAoZGlyID09PSAnYXNjJykge1xuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoeC5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHguaW5uZXJIVE1MKSA+IHBhcnNlRmxvYXQoeS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc28sIG1hcmsgYXMgYSBzd2l0Y2ggYW5kIGJyZWFrIHRoZSBsb29wOlxuICAgICAgICAgICAgICAgIHNob3VsZFN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh4LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpID4geS5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBtYXJrIGFzIGEgc3dpdGNoIGFuZCBicmVhayB0aGUgbG9vcDpcbiAgICAgICAgICAgICAgICBzaG91bGRTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvcnRfZGlyZWN0aW9uW25dID0gJ2FzYyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoeC5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHguaW5uZXJIVE1MKSA8IHBhcnNlRmxvYXQoeS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc28sIG1hcmsgYXMgYSBzd2l0Y2ggYW5kIGJyZWFrIHRoZSBsb29wOlxuICAgICAgICAgICAgICAgIHNob3VsZFN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh4LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpIDwgeS5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBtYXJrIGFzIGEgc3dpdGNoIGFuZCBicmVhayB0aGUgbG9vcDpcbiAgICAgICAgICAgICAgICBzaG91bGRTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvcnRfZGlyZWN0aW9uW25dID0gJ2Rlc2MnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU3dpdGNoKSB7XG4gICAgICAgICAgLypJZiBhIHN3aXRjaCBoYXMgYmVlbiBtYXJrZWQsIG1ha2UgdGhlIHN3aXRjaFxuICAgICAgICAgICBhbmQgbWFyayB0aGF0IGEgc3dpdGNoIGhhcyBiZWVuIGRvbmU6Ki9cbiAgICAgICAgICByb3dzW2ldLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJvd3NbaSArIDFdLCByb3dzW2ldKTtcbiAgICAgICAgICBzd2l0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgIC8vIEVhY2ggdGltZSBhIHN3aXRjaCBpcyBkb25lLCBpbmNyZWFzZSB0aGlzIGNvdW50IGJ5IDE6XG4gICAgICAgICAgc3dpdGNoY291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKklmIG5vIHN3aXRjaGluZyBoYXMgYmVlbiBkb25lIEFORCB0aGUgZGlyZWN0aW9uIGlzICdhc2MnLFxuICAgICAgICAgICBzZXQgdGhlIGRpcmVjdGlvbiB0byAnZGVzYycgYW5kIHJ1biB0aGUgd2hpbGUgbG9vcCBhZ2Fpbi4qL1xuICAgICAgICAgIGlmIChzd2l0Y2hjb3VudCA9PT0gMCAmJiBkaXIgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICBkaXIgPSAnZGVzYyc7XG4gICAgICAgICAgICB0aGlzLnNvcnRfZGlyZWN0aW9uW25dID0gJ2Rlc2MnO1xuICAgICAgICAgICAgc3dpdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==