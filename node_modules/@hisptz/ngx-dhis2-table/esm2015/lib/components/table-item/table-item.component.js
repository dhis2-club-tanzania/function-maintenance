/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { drawTable } from '../../helpers/index';
export class TableItemComponent {
    constructor() {
        this.sort_direction = [];
        this.current_sorting = [];
        this.tableObject = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.analyticsObject && this.tableConfiguration) {
            this.tableObject = drawTable(this.analyticsObject, this.tableConfiguration);
        }
    }
    /**
     * @param {?} tableObject
     * @param {?} n
     * @param {?} isLastItem
     * @return {?}
     */
    sortData(tableObject, n, isLastItem) {
        if (tableObject.columns.length === 1 && isLastItem) {
            this.current_sorting = [];
            this.current_sorting[n] = true;
            let /** @type {?} */ table, /** @type {?} */
            rows, /** @type {?} */
            switching, /** @type {?} */
            i, /** @type {?} */
            x, /** @type {?} */
            y, /** @type {?} */
            shouldSwitch, /** @type {?} */
            dir, /** @type {?} */
            switchcount = 0;
            table = document.getElementById('myPivotTable');
            switching = true;
            //  Set the sorting direction to ascending:
            dir = 'asc';
            /*Make a loop that will continue until
                   no switching has been done:*/
            while (switching) {
                //  start by saying: no switching is done:
                switching = false;
                rows = table.getElementsByTagName('TR');
                /*Loop through all table rows (except the
                         first, which contains table headers):*/
                for (i = 0; i < rows.length - 1; i++) {
                    // start by saying there should be no switching:
                    shouldSwitch = false;
                    /*Get the two elements you want to compare,
                               one from current row and one from the next:*/
                    x = rows[i].getElementsByTagName('TD')[n];
                    y = rows[i + 1].getElementsByTagName('TD')[n];
                    /*check if the two rows should switch place,
                               based on the direction, asc or desc:*/
                    if (dir === 'asc') {
                        if (parseFloat(x.innerHTML)) {
                            if (parseFloat(x.innerHTML) > parseFloat(y.innerHTML)) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        else {
                            if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        this.sort_direction[n] = 'asc';
                    }
                    else if (dir === 'desc') {
                        if (parseFloat(x.innerHTML)) {
                            if (parseFloat(x.innerHTML) < parseFloat(y.innerHTML)) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        else {
                            if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
                                // if so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                        this.sort_direction[n] = 'desc';
                    }
                }
                if (shouldSwitch) {
                    /*If a switch has been marked, make the switch
                               and mark that a switch has been done:*/
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    // Each time a switch is done, increase this count by 1:
                    switchcount++;
                }
                else {
                    /*If no switching has been done AND the direction is 'asc',
                               set the direction to 'desc' and run the while loop again.*/
                    if (switchcount === 0 && dir === 'asc') {
                        dir = 'desc';
                        this.sort_direction[n] = 'desc';
                        switching = true;
                    }
                }
            }
        }
    }
}
TableItemComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ngx-dhis2-table-item',
                template: `<div class="row">
    <div class="col-md-12" *ngIf="tableObject">
        <h5 style="margin-top: 80px" class="text-center" *ngIf="tableObject.rows.length == 0"> No data to display</h5>

        <div *ngIf="tableObject" style="padding: 3px">
            <!--<h4 *ngIf="tableObject.rows.length != 0" class="text-center" style="margin-bottom: 0px">{{tableObject?.title}}</h4>-->
            <table class="table table-bordered table-responsive table-condensed custom-table" *ngIf="tableObject.rows.length != 0">
                <thead>
                    <!--title-->
                    <tr class="table-title">
                        <th [attr.colspan]="tableObject.rows[0].items.length">
                            <h4 style="margin: 0px" class="text-center">{{tableObject.subtitle}} </h4>
                        </th>
                    </tr>
                    <!--headers-->
                    <tr *ngFor="let header of tableObject.headers; let j = index" class="header-column">
                        <th *ngIf="tableObject.hasParentOu"></th>
                        <th *ngFor="let table_column of tableObject.columns; let i = index" style="text-align: center">
                            <span *ngIf="i==tableObject.columns.length-1 && j==tableObject.headers.length-1 && tableObject.titlesAvailable">{{ tableObject.titles.rows[i] }} / {{ tableObject.titles.column[j]}}</span>
                            <span *ngIf="i != tableObject.columns.length-1">{{ tableObject.titles.rows[i] }}</span>
                            <span *ngIf="j != tableObject.headers.length-1">{{ tableObject.titles.column[j] }}</span>
                        </th>
                        <th *ngFor="let header_column of header.items; let i=index" [colSpan]="header_column.span" style="text-align: center" (click)="sortData(tableObject,i+tableObject.columns.length,j+1==tableObject.headers.length)">
                            {{ header_column.name }}
                            <span *ngIf="j+1==tableObject.headers.length && current_sorting[i+tableObject.columns.length] && sort_direction[i+tableObject.columns.length] == 'asc'" class="glyphicon glyphicon-triangle-top pull-right"></span>
                            <span *ngIf="j+1==tableObject.headers.length && current_sorting[i+tableObject.columns.length] && sort_direction[i+tableObject.columns.length] == 'desc'" class="glyphicon glyphicon-triangle-bottom pull-right"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="myPivotTable">
                    <tr *ngFor="let row of tableObject.rows" [ngClass]="{'sub-total': row.sub_total}">
                        <td *ngFor="let header_column of row.items;let i = index" [ngClass]="{'header-column': header_column.name != ''}" style="text-align: center;vertical-align: middle" [attr.rowspan]="header_column.row_span" [style.background]="header_column.color">
                            {{ header_column.val }}
                        </td>
                    </tr>
                </tbody>
            </table>


        </div>
    </div>
</div>`,
                styles: [`.table-item-container{overflow:hidden}.custom-table{display:table;border-style:none!important;width:100%}.custom-table td,.custom-table th{border:thin solid #f1f1f1}.custom-table>tbody>tr>td,.custom-table>thead>tr>th{font-size:13px!important}table tr th{background-color:rgba(238,238,238,.29);padding:4px;text-align:center}table tr td{padding:4px}table tr td:first-child{background-color:rgba(238,238,238,.29)}.table-title{font-size:13px;font-weight:600;text-align:center}`]
            },] },
];
/** @nocollapse */
TableItemComponent.ctorParameters = () => [];
TableItemComponent.propDecorators = {
    tableConfiguration: [{ type: Input }],
    analyticsObject: [{ type: Input }]
};
function TableItemComponent_tsickle_Closure_declarations() {
    /** @type {?} */
    TableItemComponent.prototype.tableConfiguration;
    /** @type {?} */
    TableItemComponent.prototype.analyticsObject;
    /** @type {?} */
    TableItemComponent.prototype.tableObject;
    /** @type {?} */
    TableItemComponent.prototype.sort_direction;
    /** @type {?} */
    TableItemComponent.prototype.current_sorting;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaXRlbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaGlzcHR6L25neC1kaGlzMi10YWJsZS8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3RhYmxlLWl0ZW0vdGFibGUtaXRlbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBR3pELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQWlEaEQsTUFBTTtJQU1KOzhCQUYyQixFQUFFOytCQUNBLEVBQUU7UUFFN0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7S0FDekI7Ozs7SUFFRCxRQUFRO1FBQ04sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUMxQixJQUFJLENBQUMsZUFBZSxFQUNwQixJQUFJLENBQUMsa0JBQWtCLENBQ3hCLENBQUM7U0FDSDtLQUNGOzs7Ozs7O0lBRUQsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsVUFBVTtRQUNqQyxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztZQUMxQixJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUMvQixxQkFBSSxLQUFLO1lBQ1AsSUFBSTtZQUNKLFNBQVM7WUFDVCxDQUFDO1lBQ0QsQ0FBQztZQUNELENBQUM7WUFDRCxZQUFZO1lBQ1osR0FBRztZQUNILFdBQVcsR0FBRyxDQUFDLENBQUM7WUFDbEIsS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMs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LEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUN2QyxHQUFHLEdBQUcsTUFBTSxDQUFDO3dCQUNiLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO3dCQUNoQyxTQUFTLEdBQUcsSUFBSSxDQUFDO3FCQUNsQjtpQkFDRjthQUNGO1NBQ0Y7S0FDRjs7O1lBdEpGLFNBQVMsU0FBQzs7Z0JBRVQsUUFBUSxFQUFFLHNCQUFzQjtnQkFDaEMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlDTDtnQkFDTCxNQUFNLEVBQUUsQ0FBQywwZEFBMGQsQ0FBQzthQUNyZTs7Ozs7aUNBRUUsS0FBSzs4QkFDTCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJsZUNvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvdGFibGUtY29uZmlndXJhdGlvbic7XG5cbmltcG9ydCB7IGRyYXdUYWJsZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXgnO1xuXG5AQ29tcG9uZW50KHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ25neC1kaGlzMi10YWJsZS1pdGVtJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiICpuZ0lmPVwidGFibGVPYmplY3RcIj5cbiAgICAgICAgPGg1IHN0eWxlPVwibWFyZ2luLXRvcDogODBweFwiIGNsYXNzPVwidGV4dC1jZW50ZXJcIiAqbmdJZj1cInRhYmxlT2JqZWN0LnJvd3MubGVuZ3RoID09IDBcIj4gTm8gZGF0YSB0byBkaXNwbGF5PC9oNT5cblxuICAgICAgICA8ZGl2ICpuZ0lmPVwidGFibGVPYmplY3RcIiBzdHlsZT1cInBhZGRpbmc6IDNweFwiPlxuICAgICAgICAgICAgPCEtLTxoNCAqbmdJZj1cInRhYmxlT2JqZWN0LnJvd3MubGVuZ3RoICE9IDBcIiBjbGFzcz1cInRleHQtY2VudGVyXCIgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiAwcHhcIj57e3RhYmxlT2JqZWN0Py50aXRsZX19PC9oND4tLT5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXJlc3BvbnNpdmUgdGFibGUtY29uZGVuc2VkIGN1c3RvbS10YWJsZVwiICpuZ0lmPVwidGFibGVPYmplY3Qucm93cy5sZW5ndGggIT0gMFwiPlxuICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPCEtLXRpdGxlLS0+XG4gICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cInRhYmxlLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggW2F0dHIuY29sc3Bhbl09XCJ0YWJsZU9iamVjdC5yb3dzWzBdLml0ZW1zLmxlbmd0aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBzdHlsZT1cIm1hcmdpbjogMHB4XCIgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPnt7dGFibGVPYmplY3Quc3VidGl0bGV9fSA8L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLWhlYWRlcnMtLT5cbiAgICAgICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBoZWFkZXIgb2YgdGFibGVPYmplY3QuaGVhZGVyczsgbGV0IGogPSBpbmRleFwiIGNsYXNzPVwiaGVhZGVyLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoICpuZ0lmPVwidGFibGVPYmplY3QuaGFzUGFyZW50T3VcIj48L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoICpuZ0Zvcj1cImxldCB0YWJsZV9jb2x1bW4gb2YgdGFibGVPYmplY3QuY29sdW1uczsgbGV0IGkgPSBpbmRleFwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJpPT10YWJsZU9iamVjdC5jb2x1bW5zLmxlbmd0aC0xICYmIGo9PXRhYmxlT2JqZWN0LmhlYWRlcnMubGVuZ3RoLTEgJiYgdGFibGVPYmplY3QudGl0bGVzQXZhaWxhYmxlXCI+e3sgdGFibGVPYmplY3QudGl0bGVzLnJvd3NbaV0gfX0gLyB7eyB0YWJsZU9iamVjdC50aXRsZXMuY29sdW1uW2pdfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJpICE9IHRhYmxlT2JqZWN0LmNvbHVtbnMubGVuZ3RoLTFcIj57eyB0YWJsZU9iamVjdC50aXRsZXMucm93c1tpXSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImogIT0gdGFibGVPYmplY3QuaGVhZGVycy5sZW5ndGgtMVwiPnt7IHRhYmxlT2JqZWN0LnRpdGxlcy5jb2x1bW5bal0gfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoICpuZ0Zvcj1cImxldCBoZWFkZXJfY29sdW1uIG9mIGhlYWRlci5pdGVtczsgbGV0IGk9aW5kZXhcIiBbY29sU3Bhbl09XCJoZWFkZXJfY29sdW1uLnNwYW5cIiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlclwiIChjbGljayk9XCJzb3J0RGF0YSh0YWJsZU9iamVjdCxpK3RhYmxlT2JqZWN0LmNvbHVtbnMubGVuZ3RoLGorMT09dGFibGVPYmplY3QuaGVhZGVycy5sZW5ndGgpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgaGVhZGVyX2NvbHVtbi5uYW1lIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJqKzE9PXRhYmxlT2JqZWN0LmhlYWRlcnMubGVuZ3RoICYmIGN1cnJlbnRfc29ydGluZ1tpK3RhYmxlT2JqZWN0LmNvbHVtbnMubGVuZ3RoXSAmJiBzb3J0X2RpcmVjdGlvbltpK3RhYmxlT2JqZWN0LmNvbHVtbnMubGVuZ3RoXSA9PSAnYXNjJ1wiIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS10b3AgcHVsbC1yaWdodFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImorMT09dGFibGVPYmplY3QuaGVhZGVycy5sZW5ndGggJiYgY3VycmVudF9zb3J0aW5nW2krdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGhdICYmIHNvcnRfZGlyZWN0aW9uW2krdGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGhdID09ICdkZXNjJ1wiIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS1ib3R0b20gcHVsbC1yaWdodFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHkgaWQ9XCJteVBpdm90VGFibGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCByb3cgb2YgdGFibGVPYmplY3Qucm93c1wiIFtuZ0NsYXNzXT1cInsnc3ViLXRvdGFsJzogcm93LnN1Yl90b3RhbH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgaGVhZGVyX2NvbHVtbiBvZiByb3cuaXRlbXM7bGV0IGkgPSBpbmRleFwiIFtuZ0NsYXNzXT1cInsnaGVhZGVyLWNvbHVtbic6IGhlYWRlcl9jb2x1bW4ubmFtZSAhPSAnJ31cIiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjt2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlXCIgW2F0dHIucm93c3Bhbl09XCJoZWFkZXJfY29sdW1uLnJvd19zcGFuXCIgW3N0eWxlLmJhY2tncm91bmRdPVwiaGVhZGVyX2NvbHVtbi5jb2xvclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IGhlYWRlcl9jb2x1bW4udmFsIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuXG5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gLFxuICBzdHlsZXM6IFtgLnRhYmxlLWl0ZW0tY29udGFpbmVye292ZXJmbG93OmhpZGRlbn0uY3VzdG9tLXRhYmxle2Rpc3BsYXk6dGFibGU7Ym9yZGVyLXN0eWxlOm5vbmUhaW1wb3J0YW50O3dpZHRoOjEwMCV9LmN1c3RvbS10YWJsZSB0ZCwuY3VzdG9tLXRhYmxlIHRoe2JvcmRlcjp0aGluIHNvbGlkICNmMWYxZjF9LmN1c3RvbS10YWJsZT50Ym9keT50cj50ZCwuY3VzdG9tLXRhYmxlPnRoZWFkPnRyPnRoe2ZvbnQtc2l6ZToxM3B4IWltcG9ydGFudH10YWJsZSB0ciB0aHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjM4LDIzOCwyMzgsLjI5KTtwYWRkaW5nOjRweDt0ZXh0LWFsaWduOmNlbnRlcn10YWJsZSB0ciB0ZHtwYWRkaW5nOjRweH10YWJsZSB0ciB0ZDpmaXJzdC1jaGlsZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjM4LDIzOCwyMzgsLjI5KX0udGFibGUtdGl0bGV7Zm9udC1zaXplOjEzcHg7Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyfWBdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIHRhYmxlQ29uZmlndXJhdGlvbjogVGFibGVDb25maWd1cmF0aW9uO1xuICBASW5wdXQoKSBhbmFseXRpY3NPYmplY3Q6IGFueTtcbiAgdGFibGVPYmplY3Q6IGFueTtcbiAgc29ydF9kaXJlY3Rpb246IHN0cmluZ1tdID0gW107XG4gIGN1cnJlbnRfc29ydGluZzogYm9vbGVhbltdID0gW107XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGFibGVPYmplY3QgPSBudWxsO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMuYW5hbHl0aWNzT2JqZWN0ICYmIHRoaXMudGFibGVDb25maWd1cmF0aW9uKSB7XG4gICAgICB0aGlzLnRhYmxlT2JqZWN0ID0gZHJhd1RhYmxlKFxuICAgICAgICB0aGlzLmFuYWx5dGljc09iamVjdCxcbiAgICAgICAgdGhpcy50YWJsZUNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc29ydERhdGEodGFibGVPYmplY3QsIG4sIGlzTGFzdEl0ZW0pIHtcbiAgICBpZiAodGFibGVPYmplY3QuY29sdW1ucy5sZW5ndGggPT09IDEgJiYgaXNMYXN0SXRlbSkge1xuICAgICAgdGhpcy5jdXJyZW50X3NvcnRpbmcgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudF9zb3J0aW5nW25dID0gdHJ1ZTtcbiAgICAgIGxldCB0YWJsZSxcbiAgICAgICAgcm93cyxcbiAgICAgICAgc3dpdGNoaW5nLFxuICAgICAgICBpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBzaG91bGRTd2l0Y2gsXG4gICAgICAgIGRpcixcbiAgICAgICAgc3dpdGNoY291bnQgPSAwO1xuICAgICAgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlQaXZvdFRhYmxlJyk7XG4gICAgICBzd2l0Y2hpbmcgPSB0cnVlO1xuICAgICAgLy8gIFNldCB0aGUgc29ydGluZyBkaXJlY3Rpb24gdG8gYXNjZW5kaW5nOlxuICAgICAgZGlyID0gJ2FzYyc7XG4gICAgICAvKk1ha2UgYSBsb29wIHRoYXQgd2lsbCBjb250aW51ZSB1bnRpbFxuICAgICAgIG5vIHN3aXRjaGluZyBoYXMgYmVlbiBkb25lOiovXG4gICAgICB3aGlsZSAoc3dpdGNoaW5nKSB7XG4gICAgICAgIC8vICBzdGFydCBieSBzYXlpbmc6IG5vIHN3aXRjaGluZyBpcyBkb25lOlxuICAgICAgICBzd2l0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgcm93cyA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUUicpO1xuICAgICAgICAvKkxvb3AgdGhyb3VnaCBhbGwgdGFibGUgcm93cyAoZXhjZXB0IHRoZVxuICAgICAgICAgZmlyc3QsIHdoaWNoIGNvbnRhaW5zIHRhYmxlIGhlYWRlcnMpOiovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIC8vIHN0YXJ0IGJ5IHNheWluZyB0aGVyZSBzaG91bGQgYmUgbm8gc3dpdGNoaW5nOlxuICAgICAgICAgIHNob3VsZFN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgIC8qR2V0IHRoZSB0d28gZWxlbWVudHMgeW91IHdhbnQgdG8gY29tcGFyZSxcbiAgICAgICAgICAgb25lIGZyb20gY3VycmVudCByb3cgYW5kIG9uZSBmcm9tIHRoZSBuZXh0OiovXG4gICAgICAgICAgeCA9IHJvd3NbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1REJylbbl07XG4gICAgICAgICAgeSA9IHJvd3NbaSArIDFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdURCcpW25dO1xuICAgICAgICAgIC8qY2hlY2sgaWYgdGhlIHR3byByb3dzIHNob3VsZCBzd2l0Y2ggcGxhY2UsXG4gICAgICAgICAgIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24sIGFzYyBvciBkZXNjOiovXG4gICAgICAgICAgaWYgKGRpciA9PT0gJ2FzYycpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHguaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdCh4LmlubmVySFRNTCkgPiBwYXJzZUZsb2F0KHkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBtYXJrIGFzIGEgc3dpdGNoIGFuZCBicmVhayB0aGUgbG9vcDpcbiAgICAgICAgICAgICAgICBzaG91bGRTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoeC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSA+IHkuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBzbywgbWFyayBhcyBhIHN3aXRjaCBhbmQgYnJlYWsgdGhlIGxvb3A6XG4gICAgICAgICAgICAgICAgc2hvdWxkU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb3J0X2RpcmVjdGlvbltuXSA9ICdhc2MnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHguaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdCh4LmlubmVySFRNTCkgPCBwYXJzZUZsb2F0KHkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBtYXJrIGFzIGEgc3dpdGNoIGFuZCBicmVhayB0aGUgbG9vcDpcbiAgICAgICAgICAgICAgICBzaG91bGRTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoeC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSA8IHkuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBzbywgbWFyayBhcyBhIHN3aXRjaCBhbmQgYnJlYWsgdGhlIGxvb3A6XG4gICAgICAgICAgICAgICAgc2hvdWxkU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb3J0X2RpcmVjdGlvbltuXSA9ICdkZXNjJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFN3aXRjaCkge1xuICAgICAgICAgIC8qSWYgYSBzd2l0Y2ggaGFzIGJlZW4gbWFya2VkLCBtYWtlIHRoZSBzd2l0Y2hcbiAgICAgICAgICAgYW5kIG1hcmsgdGhhdCBhIHN3aXRjaCBoYXMgYmVlbiBkb25lOiovXG4gICAgICAgICAgcm93c1tpXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShyb3dzW2kgKyAxXSwgcm93c1tpXSk7XG4gICAgICAgICAgc3dpdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBFYWNoIHRpbWUgYSBzd2l0Y2ggaXMgZG9uZSwgaW5jcmVhc2UgdGhpcyBjb3VudCBieSAxOlxuICAgICAgICAgIHN3aXRjaGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLypJZiBubyBzd2l0Y2hpbmcgaGFzIGJlZW4gZG9uZSBBTkQgdGhlIGRpcmVjdGlvbiBpcyAnYXNjJyxcbiAgICAgICAgICAgc2V0IHRoZSBkaXJlY3Rpb24gdG8gJ2Rlc2MnIGFuZCBydW4gdGhlIHdoaWxlIGxvb3AgYWdhaW4uKi9cbiAgICAgICAgICBpZiAoc3dpdGNoY291bnQgPT09IDAgJiYgZGlyID09PSAnYXNjJykge1xuICAgICAgICAgICAgZGlyID0gJ2Rlc2MnO1xuICAgICAgICAgICAgdGhpcy5zb3J0X2RpcmVjdGlvbltuXSA9ICdkZXNjJztcbiAgICAgICAgICAgIHN3aXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=